#!/usr/bin/env bash

# branch_only_1file.sh - Create a git branch containing only one specified file
#
# DESCRIPTION:
#   Creates a new git branch with "subset/DATE/" prefix that contains only the specified
#   file, removing all other tracked files. The branch name is derived from the
#   committer date of HEAD commit and basename of the file (without extension).
#   This is useful for creating lightweight submodules that contain only specific
#   files from larger repositories.
#
#   STORAGE EFFICIENCY:
#   These subset branches do not incur extra server-side storage space since the
#   file blobs already exist in the repository. Git's content-addressable storage
#   means identical file content is stored only once regardless of how many branches
#   reference it. However, subset branches provide significant benefits for clients:
#   - Efficient transfer: --depth 1 clones only fetch the minimal commit history
#   - Reduced local storage: Only the needed files exist in the working directory
#   - Faster operations: Git operations work on smaller trees and fewer objects
#   - Bandwidth savings: Sparse transfers avoid downloading unwanted large files
#
# USAGE:
#   ./branch_only_1file.sh <file_path>
#
# EXAMPLES:
#   ./branch_only_1file.sh grb/vector/flat1-color-dark.svg
#   # Creates branch "subset/20241225-143045/flat1-color-dark" with only grb/vector/flat1-color-dark.svg
#
#   ./branch_only_1file.sh grb/vector/flat1-bw.svg
#   # Creates branch "subset/20241225-143045/flat1-bw" with only grb/vector/flat1-bw.svg
#
#   ./branch_only_1file.sh README.md
#   # Creates branch "subset/20241225-143045/README" with only README.md
#
# WORKFLOW:
#   1. Validates file exists and we're in a git repository
#   2. Gets committer date of HEAD commit in YYYYMMDD-HHMMSS format
#   3. Creates new branch "subset/DATE/basename" where basename is file without extension
#   4. Removes all other tracked files except the target file
#   5. Commits changes locally (does not push automatically)
#
# PUSHING THE BRANCH:
#   After creating the branch locally, push it manually when ready:
#
#   git push origin subset/YYYYMMDD-HHMMSS/branch_name
#   # Example: git push origin subset/20241225-143045/flat1-color-dark
#
# USING WITH SUBMODULES:
#   After pushing the branch, you can use it as a lightweight submodule:
#
#   git submodule add -b subset/20241225-143045/flat1-color-dark --depth 1 https://github.com/example/repo.git vendor/flat1-color-dark
#   git submodule add -b subset/20241225-143045/flat1-bw --depth 1 https://github.com/example/repo.git vendor/flat1-bw
#
# FEATURES:
#   - Error handling: Checks for file existence, git repository, and handles edge cases
#   - Timestamped branch naming: Uses "subset/YYYYMMDD-HHMMSS/basename" based on HEAD commit time
#   - Safe removal: Only removes git-tracked files, preserves .git directory
#   - Idempotent: Won't create duplicate commits if run multiple times
#   - Feedback: Provides clear status messages throughout the process
#   - Storage efficient: No extra server-side space usage, optimized for client transfers
#
# REQUIREMENTS:
#   - Must be run from within a git repository
#   - File must exist and be tracked by git
#   - Write access to origin required only when pushing the branch
#
# AUTHOR: Generated for firmware/signal processing development workflows

set -e  # Exit on any error

# Store command and arguments for logging
THIS_CMD="$0"
ALL_ARGS="$*"

# Check if file argument is provided
if [ $# -ne 1 ]; then
    echo "Usage: $0 <file_path>"
    echo "Example: $0 grb/vector/flat1-color-dark.svg"
    exit 1
fi

FILE_PATH="$1"

# Check if file exists
if [ ! -f "$FILE_PATH" ]; then
    echo "Error: File '$FILE_PATH' does not exist"
    exit 1
fi

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: Not in a git repository"
    exit 1
fi

# Get basename for branch name (remove extension and path)
BASENAME=$(basename "$FILE_PATH")

# Get the committer date of HEAD commit in YYYYMMDD-HHMMSS format
COMMIT_DATE=$(git log -1 --format="%cd" --date=format:"%Y%m%d-%H%M%S" HEAD)

BRANCH_NAME="subset/${COMMIT_DATE}/${BASENAME%.*}"  # Remove extension and add subset/date/ prefix

echo "Creating branch '$BRANCH_NAME' with only file '$FILE_PATH'"

# Create and switch to new branch
git checkout -b "$BRANCH_NAME"

# Get all tracked files except our target file
FILES_TO_DELETE=$(git ls-files | grep -v "^${FILE_PATH}$" || true)

if [ -n "$FILES_TO_DELETE" ]; then
    echo "Removing all files except '$FILE_PATH'..."
    echo "$FILES_TO_DELETE" | tr '\n' '\0' | xargs -0 git rm
else
    echo "No other files to remove"
fi

# Check if there are any changes to commit
if git diff --cached --quiet; then
    echo "No changes to commit - the repository might already contain only '$FILE_PATH'"
else
    # Commit the changes
    git commit -m "Keep only $FILE_PATH" -m "" -m "Autogenerated via: $THIS_CMD $ALL_ARGS"

    echo "Successfully created branch '$BRANCH_NAME' with only '$FILE_PATH'"
fi

cat << EOF

Branch '$BRANCH_NAME' created locally and ready for use.
To push this branch to origin, run:
  git push origin $BRANCH_NAME

Then use as submodule in another repository:
  git submodule add -b $BRANCH_NAME --depth 1 <repo_url> <local_path>

  (Note: Even with --depth 1 the above may fetch more than just the HEAD commit.
    For minimal fetch, use two-step approach:
    # Step 1: Shallow clone directly
    git clone --depth 1 --single-branch --branch $BRANCH_NAME <repo_url> <local_path>
    # Step 2: Add the existing directory as a submodule
    git submodule add --branch $BRANCH_NAME <repo_url> <local_path>
  
  Both approaches are minimal fetches for people who will subsequently pull the submodule,
  but the two-step approach saves bandwidth for the one adding the submodule to begin with)

EOF
